# Questions

## 허브를 통해서 각 PC를 연결 하는것과 스위치를 통해 각 PC를 연결 하는것의 성능 차이가 있을까요?

기본적으로 허브와 스위치가 패킷을 처리하는 방식에 차이가 있습니다. 

허브는 패킷의 송신지, 수신지를 구분하지 않고 연결된 모든 포트에 플러딩(flooding)합니다. 만일 허브가 10Mbps의 대역폭을 가지고 있고 5대의 기기를 사용할 경우, 각 기기마다 2M의 대역폭을 사용하게 됩니다. 또한 반이중(half-duplex) 통신을 하기 때문에 충돌의 가능성 또한 높습니다.

스위치는 패킷의 송신지, 수신지 (MAC 주소)를 구분하여 특정 MAC 주소를 가진 기기에만 패킷을 전달합니다. 따라서 대역폭을 훨씬 효율적으로 사용하게 됩니다. 허브와 다르게 각 포트마다 다른 버스를 사용하기 때문에 충돌의 위험도 적고 충돌 시에도 서로 영향을 주지 않습니다.

따라서 허브를 사용시 더 많은 기기가 연결 될 수록 성능이 저하될 수 있고, 보안 측면에서도 위험할 수 있습니다.

----------

## TCP의 연결 생성 단계는 왜 3단계로 구성되어 있을까요?

TCP의 연결 생성 과정이 3단계인 이유는 두 컴퓨터 간에 정확한 통신을 위한 세션을 수립하는 과정이기 떄문입니다.

TCP 3-way handshake는 다음과 같은 절차로 이루어 집니다.

1. Client > Server SYN
2. Server > Client SYN ACK(이전 단계의 SYN + 1)
3. Client > Server ACK (이전 단계의 SYN + 1)

여기서, SYN은 1238679와 같이 무작위 숫자이고, 이를 잘 받았다는 의미로 SYN + 1하여 ACK에 넣어서 다시 보냅니다. 이와 같은 일련의 절차를 거쳐 세션이 수립됩니다.

----------

## IP 고갈을 방지하기 위해서 ipv6밖에 대안이 없을까요?

또 다른 방법으로는 서브넷팅과 NAT가 있습니다.

NAT는 사설 네트워크 내의 모든 기기가 public IP를 가질 필요가 없으므로 public IP를 하나만 사용하는 방법입니다. NAT 인스턴스에 public IP를 할당하고, 네트워크 내의 나머지 기기들은 private IP를 할당 받습니다.

외부로 향하는 모든 트래픽은 NAT를 거쳐 나가고, 내부로 들어올 때에도 NAT에서 주소 변환을 거쳐 다시 원래의 기기로 트래픽이 전달됩니다.

----------

## 서브넷팅이 IP 부족 현상을 막기 위해서만 필요할까요?

서브넷팅은 각각의 독립된 네트워크로 분리하는 기술입니다.

네트워크를 분리함으로써 하나의 네트워크 당 할당할 수 있는 IP의 갯수를 제한할 수 있고, 브로드캐스팅 시 불필요한 메시지의 전달을 줄일 수 있습니다.

----------

## 내 PC에서 넷플릭스 접속시 꼭 라우터가 있어야 하나요? 

우선 라우터가 하는 일은 크게 2가지 입니다.

1. 알고리즘을 통해 목적지에 도달하기 위한 최적의 경로를 찾는 **"라우팅"**
2. 패킷을 다음 라우터로 전달하는 **"포워딩"**

넷플릭스 서버에 접속하기 위해서는 인터넷을 이용하게 되는데, 인터넷에서 넷플릭스 서버의 물리적 주소를 찾는 과정(라우팅)을 라우터가 수행하기 때문에 라우터가 필요합니다.

## 정확히 넷플릭스 서버로 패킷이 전달될 때 목적지를 어떻게 찾게 되나요?

그리고 라우터는 최적의 경로를 찾기 위해서 주변 라우터끼리 라우팅 프로토콜(BGP, OSPF)을 보내 네트워크 정보를 주고 받습니다.

OSPF 프로토콜을 주고 받아 네트워크의 전반적인 형태를 파악하고, 다익스트라( Dijkstra) 알고리즘을 이용해 최적의 경로를 찾습니다. 이 경로를 라우팅 테이블에 작성합니다.

BGP 역시 네트워크 정보를 주고 받지만, 다익스트라 알고리즘 대신 AS의 정책에 기반하여 경로를 결정하거나 가장 적은 수의 ISP를 거쳐 가는 경로를 선택합니다.

이 과정을 통해 얻은 라우팅 테이블을 보고 라우팅, 포워딩을 수행하게됩니다.

----------

## www.naver.com 쿼리시 항상 com 네임서버를 호출하게 되나요?

도메인을 IP로 변환하기 위해서는 다음의 순서로 참조하게 됩니다.

1. hosts file: PC내에 존재하는 파일, 사용자가 수정할 수 있음
2. DNS cache: 이전에 쿼리한 도메인을 일정 시간동안(TTL) 캐시함
3. DNS Server

1, 2 과정에서 해당 도메인을 찾지 못했을 경우 DNS 서버로 요청을 보내게 됩니다. 
하지만 DNS 서버 내에도 캐시 기능을 갖추고 있기 때문에 항상 com 네임서버를 호출 하지는 않습니다.

----------

## hosts가 먼저 참조 되는 순서 변경이 가능한가요?

리눅스 환경에서는 /etc/netsvc.conf 파일을 변경하여 /etc/hosts와 /etc/resolv.conf의 참조 순서를 변경할 수 있습니다.

윈도우의 경우 ICS(internet connection sharing, VM이나 WSL등에 인터넷 연결 공유를 위해 주로 사용됨)를 위해 hosts.ics 파일을 사용하게 되는데, 이 파일이 hosts 파일보다 우선 참조합니다.

----------

## TCP 3 handshake에서 첫 연결 시도시 발생하는 문제?

### Connection timeout
클라이언트와 서버에 연결(tcp 3-way handshake)하고자 하였으나, 서버 측의 장애나 오류등으로 연결이 맺어지지 않았을 때 발생합니다.

TCP 연결 과정은 다음과 같은데, 
1. 클라이언트 A가 서버 B에 SYN을 보낸다. A는 SYN_SENT 상태가 된다.
2. B가 SYN 요청을 받고 A에 SYN/ACK를 보낸다. B는 SYN_RECEIVED 상태가 된다.
3. A가 SYN/ACK를 받고 B서버에 ACK를 보낸다. A는 ESTABLISHED가 되고, B는 ACK를 받고 ESTABLISHED가 된다.

이 과정에서 클라이언트 A가 ESTABLISHED 되지 않고 Timeout 되었을 경우 Connection timeout이 발생합니다. 이는 주로 방화벽에 차단되는 등의 이유로 오류가 발생합니다.

### SYN Flooding
SYN Flooding은 Dos 공격 기법중 하나로, TCP 3-way handshake의 취약점을 이용하여 공격합니다.

서버는 클라이언트로부터 연결 요청(SYN)을 받고 Backlog Queue에 연결 요청 정보를 저장하게 되는데, 클라이언트가 ACK를 보내지 않을 경우 Queue에 계속 남아있게 됩니다. 이를 계속해서 많은 클라이언트로부터 동시에 요청을 받아 Queue가 가득 찰 경우 다른 연결을 받지 못하게 됩니다.

이에 대한 대응책으로는
- Backlog Queue의 크기를 늘린다. 다만, 이는 임시적으로 해결할 뿐이다.
- SYN Cookie를 설정한다. Queue에 연결 정보를 저장하는 것이 아닌, 쿠키에 정보를 넣고 ACK를 받았을 때 쿠키의 값을 검증한다.
- 동일 IP로부터 오는 SYN의 임계치를 설정한다.
- TCP 연결 대기시간을 줄인다.

----------

## TCP 4 handshake에서 리눅스 소켓 close wait과 time wait의 차이점

4-way handshake는 다음의 과정을 거치게 됩니다.
![4way](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtQR1l%2FbtqyJRYdm3E%2F143elB5WCHDlofiAsax2J1%2Fimg.png)
[이미지 출처](https://seongonion.tistory.com/74)

위의 이미지에서 각 소켓의 상태는 다음과 같습니다.
- ESTABLISHED: 연결이 되어 있어 서로 통신이 가능한 상태
- FIN-WAIT-1: 연결을 종료하고자 FIN을 보냈고, 상대방의 ACK나 FIN의 수신을 기다리는 상태
- FIN-WAIT-2: 연결 종료 FIN에 대한 ACK를 받았고, 상대방의 FIN의 수신을 기다리는 상태
- CLOSE-WAIT: 상대방으로부터 FIN을 수신하고 ACK를 보낸 상태. 남아있는 패킷이 있다면 그때까지 기다린다.
- LAST-ACK: CLOSE-WAIT이후 상대방에게 FIN을 보내어 ACK를 기다리는 상태
- TIME-WAIT: 모든 FIN에 대한 ACK를 받아 연결을 종료한 상태.

CLOSE-WAIT은 FIN의 요청을 받고 ACK에 대해 응답을 마친 상태입니다. 하지만 자신이 보내야 할 패킷이 남아있는 경우 모두 보내고 난 후 FIN을 다시 보내게 됩니다.

TIME-WAIT은 양측이 보낸 FIN이 모두 처리된 상태입니다. 하지만 패킷 손실에 의한 재전송을 대비하여 존재하는 소켓입니다.

## 각 단계에서 나올수 있는 문제들

### CLOSE-WAIT 무한 대기

FIN을 요청받은 측(Passive closer)은 ACK응답한 후 CLOSE-WAIT 상태에 들어가게 됩니다. 하지만 명시적으로 close() 해주지 않는다면 무한 대기상태가 될 수 있습니다.
